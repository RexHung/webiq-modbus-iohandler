# This is a basic workflow to help you get started with Actions
# 備註：
# unit 工作只做編譯＋（可選）CTests（若暫未加測試程式，先允許通過）。
# integration 工作安裝 libmodbus-dev，以 pymodbus 啟用 TCP 模擬器，然後跑我們的 E2E 測試程式。


name: CI

# Controls when the workflow will run
on: [push, pull_request]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # ------------------------------------------
  # Unit / Component（無外部依賴，stub backend）
  # - 以 matrix 控制是否編譯測試 (WITH_TESTS=ON/OFF)
  # - 可在 Windows / Ubuntu 上各跑一次
  # ------------------------------------------
  unit:
    name: Unit (${{ matrix.os }}, arch=${{ matrix.arch }}, WITH_TESTS=${{ matrix.with_tests }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux arches
          - { os: ubuntu-latest, arch: x86_64, with_tests: ON }
          - { os: ubuntu-latest, arch: x86_64, with_tests: OFF }
          - { os: ubuntu-latest, arch: i386,   with_tests: ON }
          - { os: ubuntu-latest, arch: i386,   with_tests: OFF }
          - { os: ubuntu-latest, arch: armhf,  with_tests: OFF }  # compile-only under QEMU
          - { os: ubuntu-latest, arch: arm64,  with_tests: OFF }  # compile-only under QEMU
          # Windows arches
          - { os: windows-latest, arch: win64, with_tests: ON }
          - { os: windows-latest, arch: win64, with_tests: OFF }
          - { os: windows-latest, arch: win32, with_tests: ON }
          - { os: windows-latest, arch: win32, with_tests: OFF }
    steps:
      - uses: actions/checkout@v4

      # Linux: install toolchains as needed
      - name: Install cross/multilib deps (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          case "${{ matrix.arch }}" in \
            i386) \
              sudo dpkg --add-architecture i386; \
              sudo apt-get update; \
              sudo apt-get install -y g++-multilib libc6:i386 libstdc++6:i386 ;; \
            armhf) sudo apt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf qemu-user qemu-user-static binfmt-support ;; \
            arm64) sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu qemu-user qemu-user-static binfmt-support ;; \
            *) ;; \
          esac

      # Configure by arch/OS
      - name: Configure (Linux x86_64)
        if: runner.os == 'Linux' && matrix.arch == 'x86_64'
        run: cmake -S . -B build -DWITH_LIBMODBUS=OFF -DWITH_TESTS=${{ matrix.with_tests }} -DCMAKE_BUILD_TYPE=Release

      - name: Configure (Linux i386)
        if: runner.os == 'Linux' && matrix.arch == 'i386'
        run: |
          cmake -S . -B build -DWITH_LIBMODBUS=OFF -DWITH_TESTS=${{ matrix.with_tests }} -DCMAKE_BUILD_TYPE=Release \
                -DCMAKE_C_FLAGS=-m32 -DCMAKE_CXX_FLAGS=-m32

      - name: Configure (Linux armhf)
        if: runner.os == 'Linux' && matrix.arch == 'armhf'
        run: cmake -S . -B build -DWITH_LIBMODBUS=OFF -DWITH_TESTS=${{ matrix.with_tests }} -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=cmake/toolchains/armhf.cmake

      - name: Configure (Linux arm64)
        if: runner.os == 'Linux' && matrix.arch == 'arm64'
        run: cmake -S . -B build -DWITH_LIBMODBUS=OFF -DWITH_TESTS=${{ matrix.with_tests }} -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=cmake/toolchains/arm64.cmake

      - name: Configure (Windows x64)
        if: runner.os == 'Windows' && matrix.arch == 'win64'
        run: cmake -S . -B build -G "Visual Studio 17 2022" -A x64 -DWITH_LIBMODBUS=OFF -DWITH_TESTS=${{ matrix.with_tests }} -DCMAKE_BUILD_TYPE=Release

      - name: Configure (Windows x86)
        if: runner.os == 'Windows' && matrix.arch == 'win32'
        run: cmake -S . -B build -G "Visual Studio 17 2022" -A Win32 -DWITH_LIBMODBUS=OFF -DWITH_TESTS=${{ matrix.with_tests }} -DCMAKE_BUILD_TYPE=Release

      - name: Build
        run: cmake --build build --config Release --parallel

      - name: Set unit test regex (Linux)
        if: matrix.with_tests == 'ON' && runner.os == 'Linux'
        run: |
          case "${{ matrix.arch }}" in \
            x86_64|i386) echo "CTEST_REGEX=^unit_.*" >> $GITHUB_ENV ;; \
            armhf|arm64) echo "CTEST_REGEX=^unit_(stub|codec|config_invalid|api_float_swap|api_coils_array)$" >> $GITHUB_ENV ;; \
            *) echo "CTEST_REGEX=^unit_.*" >> $GITHUB_ENV ;; \
          esac

      - name: Set unit test regex (Windows)
        if: matrix.with_tests == 'ON' && runner.os == 'Windows'
        shell: pwsh
        run: |
          if ($env:RUNNER_OS -eq 'Windows') { $regex = '^unit_.*' } else { $regex = '^unit_.*' }
          "CTEST_REGEX=$regex" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Run unit tests (Linux x86_64/i386, Windows x64/x86)
        if: matrix.with_tests == 'ON' && ((runner.os == 'Linux' && (matrix.arch == 'x86_64' || matrix.arch == 'i386')) || (runner.os == 'Windows' && (matrix.arch == 'win64' || matrix.arch == 'win32')))
        run: ctest --test-dir build -R "$CTEST_REGEX" --output-on-failure --timeout 60

      - name: Run unit tests under QEMU (Linux ARM)
        if: matrix.with_tests == 'ON' && runner.os == 'Linux' && (matrix.arch == 'armhf' || matrix.arch == 'arm64')
        env:
          CTEST_PARALLEL_LEVEL: 1
        run: ctest --test-dir build -R "$CTEST_REGEX" --output-on-failure --timeout 180

      - name: Upload unit test logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ctest-logs-unit-${{ matrix.os }}-${{ matrix.arch }}-tests_${{ matrix.with_tests }}
          path: |
            build/Testing
            build/LastTest.log
            build/**/LastTest.log

  # ------------------------------------------------------
  # Integration（libmodbus + Modbus TCP 模擬器 via PORT）
  # - 以 matrix 同步開多個埠號做平行測試
  # - WITH_TESTS 固定 ON（需要建 test_e2e）
  # ------------------------------------------------------
  integration:
    name: Integration (${{ matrix.os }}, port=${{ matrix.port }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        os: [ubuntu-latest, windows-latest]
        port: [1502, 1503]
    env:
      PORT: ${{ matrix.port }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.x
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install pymodbus
        run: |
          python -m pip install --upgrade pip
          python -m pip install pymodbus

      # Linux deps: libmodbus via apt
      - name: Install libmodbus (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libmodbus-dev

      # Windows deps: libmodbus via vcpkg
      - name: Set up vcpkg (Windows)
        if: runner.os == 'Windows'
        uses: microsoft/vcpkg-action@v1

      - name: Cache vcpkg artifacts (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.VCPKG_ROOT }}\installed
            ${{ env.VCPKG_ROOT }}\downloads
          key: vcpkg-${{ runner.os }}-libmodbus
          restore-keys: |
            vcpkg-${{ runner.os }}-

      - name: Install libmodbus with vcpkg (Windows)
        if: runner.os == 'Windows'
        run: vcpkg install libmodbus:x64-windows

      - name: Add vcpkg runtime to PATH (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $bin = Join-Path $env:VCPKG_ROOT 'installed\x64-windows\bin'
          echo "Adding $bin to PATH"
          echo ("PATH=$env:PATH;" + $bin) | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Start Modbus TCP simulator (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          echo "Starting simulator on port $PORT"
          python tests/integration/modbus_sim.py &
          # Probe readiness for up to ~20s using bash /dev/tcp
          for i in {1..20}; do
            sleep 1
            if (echo > /dev/tcp/127.0.0.1/$PORT) >/dev/null 2>&1; then
              echo "Simulator is ready on port $PORT"; break
            fi
          done
          if ! (echo > /dev/tcp/127.0.0.1/$PORT) >/dev/null 2>&1; then
            echo "ERROR: Simulator not reachable on port $PORT"; exit 1
          fi

      - name: Start Modbus TCP simulator (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Starting simulator on port $env:PORT"
          Start-Process -FilePath python -ArgumentList 'tests/integration/modbus_sim.py'
          # Longer warm-up and readiness probe on Windows
          $deadline = (Get-Date).AddSeconds(25)
          $ok = $false
          do {
            Start-Sleep -Seconds 1
            try {
              $t = Test-NetConnection -ComputerName 127.0.0.1 -Port $env:PORT -WarningAction SilentlyContinue
              if ($t.TcpTestSucceeded) { $ok = $true }
            } catch { }
          } until ($ok -or (Get-Date) -gt $deadline)
          if (-not $ok) { Write-Error "Simulator not reachable on port $env:PORT"; exit 1 }

      - name: Prepare CI config (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          mkdir -p config
          cat > config/ci.modbus.json <<JSON
          {
            "transport": "tcp",
            "tcp": { "host": "127.0.0.1", "port": $PORT, "timeout_ms": 1000 },
            "items": [
              { "name": "coil.run",      "unit_id": 1, "function": 1,  "address": 10,  "type": "bool",  "poll_ms": 100 },
              { "name": "holding.temp",  "unit_id": 1, "function": 3,  "address": 0,   "type": "int16", "scale": 0.1, "poll_ms": 100 },
              { "name": "ai.flow",       "unit_id": 1, "function": 4,  "address": 100, "type": "float", "poll_ms": 100, "swap_words": false }
            ]
          }
          JSON

      - name: Prepare CI config (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path config | Out-Null
          @"
          {
            "transport": "tcp",
            "tcp": { "host": "127.0.0.1", "port": $env:PORT, "timeout_ms": 1000 },
            "items": [
              { "name": "coil.run",      "unit_id": 1, "function": 1,  "address": 10,  "type": "bool",  "poll_ms": 100 },
              { "name": "holding.temp",  "unit_id": 1, "function": 3,  "address": 0,   "type": "int16", "scale": 0.1, "poll_ms": 100 },
              { "name": "ai.flow",       "unit_id": 1, "function": 4,  "address": 100, "type": "float", "poll_ms": 100, "swap_words": false }
            ]
          }
          "@ | Out-File -FilePath config/ci.modbus.json -Encoding utf8 -Force

      - name: Configure (Ubuntu, WITH_LIBMODBUS=ON, WITH_TESTS=ON)
        if: runner.os == 'Linux'
        run: cmake -S . -B build -DWITH_LIBMODBUS=ON -DWITH_TESTS=ON -DCMAKE_BUILD_TYPE=Release

      - name: Configure (Windows, WITH_LIBMODBUS=ON, WITH_TESTS=ON)
        if: runner.os == 'Windows'
        run: |
          cmake -S . -B build -A x64 \
            -DWITH_LIBMODBUS=ON -DWITH_TESTS=ON \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_TOOLCHAIN_FILE=$env:VCPKG_ROOT\scripts\buildsystems\vcpkg.cmake

      - name: Build
        run: cmake --build build --config Release --parallel

      - name: Run E2E integration test (ctest -R e2e)
        run: ctest --test-dir build -R e2e --output-on-failure --timeout 120

      - name: Show dependency info (Linux)
        if: runner.os == 'Linux'
        run: |
          echo "-- ldd test_e2e --" || true
          ldd ./build/tests/integration/test_e2e || true
          echo "-- locate and ldd ioh_modbus --" || true
          find build -type f -name "libioh_modbus*.so" -print -exec ldd {} \; || true

      - name: Show PATH and files (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "PATH=$env:PATH"
          Get-ChildItem -Recurse build -Filter ioh_modbus*.dll | Select-Object -First 10 -ExpandProperty FullName

      - name: Upload integration logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ctest-logs-integration-${{ matrix.os }}-port_${{ matrix.port }}
          path: |
            build/Testing
            build/LastTest.log
            build/**/LastTest.log
